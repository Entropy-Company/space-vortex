using System;
using System.Collections.Generic;
using System.Linq;
using System.Numerics;
using Content.Client.UserInterface.Controls;
using Content.Shared.Access.Components;
using Content.Shared.Access.Systems;
using Content.Shared.Research.Components;
using Content.Shared.Research.Prototypes;
using Robust.Client.AutoGenerated;
using Robust.Client.GameObjects;
using Robust.Client.Graphics;
using Robust.Client.Player;
using Robust.Client.UserInterface;
using Robust.Client.UserInterface.Controls;
using Robust.Client.UserInterface.XAML;
using Robust.Shared.Input;
using Robust.Shared.Prototypes;
using Robust.Shared.Utility;
using Robust.Shared.Maths;
using Robust.Client.UserInterface.CustomControls;
using Robust.Shared.Log;

namespace Content.Client.Research.UI;

[GenerateTypedNameReferences]
public sealed partial class ResearchConsoleMenu : FancyWindow
{
    public Action<string>? OnTechnologyCardPressed;
    public Action? OnServerButtonPressed;

    [Dependency] private readonly IEntityManager _entity = default!;
    [Dependency] private readonly IPrototypeManager _prototype = default!;
    [Dependency] private readonly IPlayerManager _player = default!;
    private readonly ResearchSystem _research;
    private readonly SpriteSystem _sprite;
    private readonly AccessReaderSystem _accessReader;

    public EntityUid Entity;
    public ProtoId<TechDisciplinePrototype> CurrentDiscipline = "Industrial";
    public Dictionary<string, ResearchAvailablity> List = new();
    internal ResearchConsoleBoundInterfaceState _localState = new(0);
    private bool _dragging;
    private TechnologyPrototype? _selectedTechnology;
    private string? _playerSelectedTechnologyId;
    private bool _playerHasMadeSelection = false;
    private TechTreeLinesControl? _linesControl;
    private Vector2 _position = new Vector2(45, 250);
    private TechnologyPrototype? _lastSelectedTechnology;

    public ResearchConsoleMenu()
    {
        RobustXamlLoader.Load(this);
        IoCManager.InjectDependencies(this);
        _research = _entity.System<ResearchSystem>();
        _sprite = _entity.System<SpriteSystem>();
        _accessReader = _entity.System<AccessReaderSystem>();

        _linesControl = new TechTreeLinesControl();
        LinesContainer.AddChild(_linesControl);
        _linesControl.SetPositionInParent(0);
        LayoutContainer.SetPosition(_linesControl, Vector2.Zero);
        _linesControl.HorizontalExpand = true;
        _linesControl.VerticalExpand = true;
        _linesControl.DragContainer = DragContainer;

        DragContainer.OnResized += delegate { UpdateLineCenters(); };

        ServerButton.OnPressed += _ => OnServerButtonPressed?.Invoke();
        DragContainer.OnKeyBindDown += args => OnKeybindDown(args);
        DragContainer.OnKeyBindUp += args => OnKeybindUp(args);
        RecenterButton.OnPressed += _ => Recenter();
    }

    public void SetEntity(EntityUid entity)
    {
        Entity = entity;
    }

    public void UpdatePanels(ResearchConsoleBoundInterfaceState state)
    {
        DragContainer.DisposeAllChildren();
        DisciplinesContainer.DisposeAllChildren();
        _localState = state;
        _playerHasMadeSelection = false;

        // Сохраняем текущую выбранную технологию
        var previousSelectedTech = _lastSelectedTechnology;

        var disciplines = _prototype.EnumeratePrototypes<TechDisciplinePrototype>()
            .OrderBy(x => x.Name)
            .ToList();
        foreach (var proto in disciplines)
        {
            var discipline = new DisciplineButton(proto)
            {
                ToggleMode = true,
                HorizontalExpand = true,
                VerticalExpand = true,
                MuteSounds = true,
                Text = Loc.GetString(proto.MenuName ?? proto.Name),
                Margin = new(5)
            };
            discipline.SetClickPressed(proto.ID == CurrentDiscipline);
            DisciplinesContainer.AddChild(discipline);
            discipline.OnPressed += SelectDiscipline;
        }

        if (!_entity.TryGetComponent(Entity, out TechnologyDatabaseComponent? database))
            return;
        var disciplineLevel = _research.GetHighestDisciplineTier(database, _prototype.Index<TechDisciplinePrototype>(CurrentDiscipline));

        var techs = _prototype.EnumeratePrototypes<TechnologyPrototype>()
            .Where(x => x.Discipline == CurrentDiscipline && x.Position != null)
            .OrderBy(x => x.Position!.Value.Y).ThenBy(x => x.Position!.Value.X)
            .ToList();

        foreach (var tech in techs)
        {
            bool unlocked = _research.IsTechnologyUnlocked(Entity, tech, database);
            bool prereqsMet = tech.RequiredTech == null || tech.RequiredTech.All(req => _research.IsTechnologyUnlocked(Entity, _prototype.Index<TechnologyPrototype>(req), database));
            bool available = _research.IsTechnologyAvailable(database, tech) && tech.Tier <= disciplineLevel && prereqsMet;
            var control = new MiniTechnologyCardControl(tech, _prototype, _sprite, new FormattedMessage());
            DragContainer.AddChild(control);
            var tilePos = _position + tech.Position!.Value * 150;
            LayoutContainer.SetPosition(control, tilePos);
            if (unlocked)
                control.SetAvailability(ResearchAvailablity.Researched);
            else if (available)
                control.SetAvailability(ResearchAvailablity.Available);
            else
                control.SetAvailability(ResearchAvailablity.Unavailable);
            control.OnTileClicked += () => {
                _selectedTechnology = tech;
                _playerSelectedTechnologyId = tech.ID;
                _playerHasMadeSelection = true;
                SelectTech(tech, unlocked ? ResearchAvailablity.Researched : (available ? ResearchAvailablity.Available : ResearchAvailablity.Unavailable));
            };
            if (_selectedTechnology != null && _selectedTechnology.ID == tech.ID)
                SelectTech(tech, unlocked ? ResearchAvailablity.Researched : (available ? ResearchAvailablity.Available : ResearchAvailablity.Unavailable));
        }

        // Восстанавливаем выбранную технологию, если она все еще доступна в текущей дисциплине
        if (previousSelectedTech != null && techs.Any(t => t.ID == previousSelectedTech.ID))
        {
            _lastSelectedTechnology = previousSelectedTech;
        }
        else
        {
            _lastSelectedTechnology = null;
        }

        if (_linesControl != null)
        {
            _linesControl.NodeCenters.Clear();
            _linesControl.Edges.Clear();
            _linesControl.NodeStatuses.Clear();

            foreach (var child in DragContainer.Children)
            {
                if (child is MiniTechnologyCardControl card)
                {
                    var tech = card.Technology;
                    var tilePos = _position + tech.Position!.Value * 150;
                    var center = tilePos + new Vector2(40, 40);
                    _linesControl.NodeCenters[tech.ID] = center;

                    bool unlocked = _research.IsTechnologyUnlocked(Entity, tech, database);
                    bool prereqsMet = tech.RequiredTech == null || tech.RequiredTech.All(req => _research.IsTechnologyUnlocked(Entity, _prototype.Index<TechnologyPrototype>(req), database));
                    bool available = _research.IsTechnologyAvailable(database, tech) && tech.Tier <= disciplineLevel && prereqsMet;

                    var status = unlocked ? ResearchAvailablity.Researched :
                                (available ? ResearchAvailablity.Available : ResearchAvailablity.Unavailable);
                    _linesControl.NodeStatuses[tech.ID] = status;
                }
            }

            foreach (var tech in techs)
            {
                if (tech.RequiredTech != null)
                {
                    foreach (var prereq in tech.RequiredTech)
                    {
                        _linesControl.Edges.Add((prereq, tech.ID));
                    }
                }
            }
            _linesControl.QueueRedraw();
        }
        if (_selectedTechnology != null)
        {
            var newTech = techs.FirstOrDefault(t => t.ID == _selectedTechnology.ID);
            if (newTech != null)
            {
                _selectedTechnology = newTech;
                if (_entity.TryGetComponent(Entity, out TechnologyDatabaseComponent? database2))
                {
                    bool unlocked = _research.IsTechnologyUnlocked(Entity, _selectedTechnology, database2);
                    bool prereqsMet = _selectedTechnology.RequiredTech == null || _selectedTechnology.RequiredTech.All(req => _research.IsTechnologyUnlocked(Entity, _prototype.Index<TechnologyPrototype>(req), database2));
                    var disciplineLevel2 = _research.GetHighestDisciplineTier(database2, _prototype.Index<TechDisciplinePrototype>(CurrentDiscipline));
                    bool available = _research.IsTechnologyAvailable(database2, _selectedTechnology) && _selectedTechnology.Tier <= disciplineLevel2 && prereqsMet;
                    SelectTech(_selectedTechnology, unlocked ? ResearchAvailablity.Researched : (available ? ResearchAvailablity.Available : ResearchAvailablity.Unavailable));
                }
            }
        }
    }

    public void UpdateInformationPanel(ResearchConsoleBoundInterfaceState state)
    {
        var amountMsg = new FormattedMessage();
        amountMsg.AddMarkupOrThrow(Loc.GetString("research-console-menu-research-points-text", ("points", state.Points)));
        ResearchAmountLabel.SetMessage(amountMsg);

        if (!_entity.TryGetComponent(Entity, out TechnologyDatabaseComponent? database))
            return;

        TierDisplayContainer.DisposeAllChildren();
        foreach (var disciplineId in database.SupportedDisciplines)
        {
            var discipline = _prototype.Index<TechDisciplinePrototype>(disciplineId);
            var tier = _research.GetHighestDisciplineTier(database, discipline);
            if (tier == 0)
                continue;
            var texture = new TextureRect
            {
                TextureScale = new Vector2(2, 2),
                VerticalAlignment = VAlignment.Center
            };
            var label = new RichTextLabel();
            texture.Texture = _sprite.Frame0(discipline.Icon);
            label.SetMessage(Loc.GetString("research-console-tier-info-small", ("tier", tier)));
            var control = new BoxContainer
            {
                Children =
                {
                    texture,
                    label,
                    new Control { MinWidth = 10 }
                }
            };
            TierDisplayContainer.AddChild(control);
        }

        // Обновляем состояние кнопки выбранной технологии
        UpdateSelectedTechnologyButtonState();
    }

    #region Drag handle
    protected override void MouseMove(GUIMouseMoveEventArgs args)
    {
        base.MouseMove(args);
        if (_dragging)
        {
            _position += args.Relative;
            foreach (var child in DragContainer.Children)
            {
                LayoutContainer.SetPosition(child, child.Position + args.Relative);
            }
            UpdateLineCenters();
        }
    }
    private void OnKeybindDown(GUIBoundKeyEventArgs args)
    {
        if (args.Function == EngineKeyFunctions.Use)
            _dragging = true;
    }
    private void OnKeybindUp(GUIBoundKeyEventArgs args)
    {
        if (args.Function == EngineKeyFunctions.Use)
            _dragging = false;
    }
    protected override DragMode GetDragModeFor(Vector2 relativeMousePos)
    {
        return _dragging ? DragMode.None : base.GetDragModeFor(relativeMousePos);
    }
    #endregion

    public void SelectTech(TechnologyPrototype proto, ResearchAvailablity avaibility)
    {
        if (_lastSelectedTechnology?.ID == proto.ID)
            return;

        _lastSelectedTechnology = proto;
        InfoContainer.DisposeAllChildren();
        if (!_player.LocalEntity.HasValue)
            return;
        if (!_entity.TryGetComponent(Entity, out TechnologyDatabaseComponent? database))
            return;
        var hasAccess = _accessReader.IsAllowed(_player.LocalEntity.Value, Entity);
        var infoPanel = new TechnologyInfoPanel(proto, _sprite, hasAccess, avaibility);
        infoPanel.BuyAction = _ => OnTechnologyCardPressed?.Invoke(proto.ID);
        InfoContainer.AddChild(infoPanel);

        // Обновляем состояние кнопки с учетом текущих очков
        infoPanel.UpdateButtonState(hasAccess, avaibility, _localState.Points);
    }

    /// <summary>
    /// Обновляет только состояние кнопки выбранной технологии без пересоздания панели
    /// </summary>
    public void UpdateSelectedTechnologyButtonState()
    {
        if (_lastSelectedTechnology == null || !_player.LocalEntity.HasValue)
            return;
        if (!_entity.TryGetComponent(Entity, out TechnologyDatabaseComponent? database))
            return;

        var hasAccess = _accessReader.IsAllowed(_player.LocalEntity.Value, Entity);
        bool unlocked = _research.IsTechnologyUnlocked(Entity, _lastSelectedTechnology, database);
        bool prereqsMet = _lastSelectedTechnology.RequiredTech == null || _lastSelectedTechnology.RequiredTech.All(req => _research.IsTechnologyUnlocked(Entity, _prototype.Index<TechnologyPrototype>(req), database));
        var disciplineLevel = _research.GetHighestDisciplineTier(database, _prototype.Index<TechDisciplinePrototype>(CurrentDiscipline));
        bool available = _research.IsTechnologyAvailable(database, _lastSelectedTechnology) && _lastSelectedTechnology.Tier <= disciplineLevel && prereqsMet;

        var availablity = unlocked ? ResearchAvailablity.Researched : (available ? ResearchAvailablity.Available : ResearchAvailablity.Unavailable);

        // Получаем количество доступных очков
        int availablePoints = _localState.Points;

        // Находим панель в InfoContainer и обновляем только кнопку
        foreach (var child in InfoContainer.Children)
        {
            if (child is TechnologyInfoPanel infoPanel && infoPanel.Prototype.ID == _lastSelectedTechnology.ID)
            {
                infoPanel.UpdateButtonState(hasAccess, availablity, availablePoints);
                break;
            }
        }
    }

    public void SelectDiscipline(BaseButton.ButtonEventArgs args)
    {
        if (args.Button is not DisciplineButton discipline)
            return;
        var proto = discipline.Proto;
        CurrentDiscipline = proto.ID;
        discipline.SetClickPressed(false);
        UserInterfaceManager.ClickSound();
        _lastSelectedTechnology = null;
        UpdatePanels(_localState);
        Recenter();
    }

    public void Recenter()
    {
        _position = new Vector2(45, 250);
        foreach (var child in DragContainer.Children)
        {
            if (child is MiniTechnologyCardControl card)
                LayoutContainer.SetPosition(card, _position + card.Technology.Position!.Value * 150);
        }
        UpdateLineCenters();
        LayoutContainer.SetPosition(LinesContainer, DragContainer.Position);
    }

    public override void Close()
    {
        base.Close();
    }

    protected override void Dispose(bool disposing)
    {
        InfoContainer.DisposeAllChildren();
        foreach (var item in DisciplinesContainer.Children)
        {
            if (item is not DisciplineButton button)
                continue;
            button.OnPressed -= SelectDiscipline;
        }
        base.Dispose(disposing);
    }

    private void UpdateLineCenters()
    {
        if (_linesControl == null)
            return;
        _linesControl.NodeCenters.Clear();
        _linesControl.NodeStatuses.Clear();
        if (!_entity.TryGetComponent(Entity, out TechnologyDatabaseComponent? database))
            return;
        var disciplineLevel = _research.GetHighestDisciplineTier(database, _prototype.Index<TechDisciplinePrototype>(CurrentDiscipline));
        foreach (var child in DragContainer.Children)
        {
            if (child is MiniTechnologyCardControl card)
            {
                var center = card.Position + card.Size / 2f;
                _linesControl.NodeCenters[card.Technology.ID] = center;
            }
        }
        _linesControl.QueueRedraw();
    }

    private sealed partial class DisciplineButton(TechDisciplinePrototype proto) : Button
    {
        public TechDisciplinePrototype Proto = proto;
    }
}

