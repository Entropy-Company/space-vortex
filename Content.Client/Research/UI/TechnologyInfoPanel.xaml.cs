using Content.Client.Lathe;
using Content.Shared.Research.Prototypes;
using Robust.Client.AutoGenerated;
using Robust.Client.GameObjects;
using Robust.Client.UserInterface;
using Robust.Client.UserInterface.Controls;
using Robust.Client.UserInterface.XAML;
using Robust.Shared.Prototypes;
using Robust.Client.Graphics;
using Robust.Shared.Utility;
using System.Numerics;

namespace Content.Client.Research.UI;

[GenerateTypedNameReferences]
public sealed partial class TechnologyInfoPanel : Control
{
    [Dependency] private readonly IEntityManager _ent = default!;
    [Dependency] private readonly IPrototypeManager _proto = default!;
    private readonly LatheSystem _lathe;

    public TechnologyPrototype Prototype;
    public Action<TechnologyPrototype>? BuyAction;

    public TechnologyInfoPanel(TechnologyPrototype proto, SpriteSystem sprite, bool hasAccess, ResearchAvailablity availablity)
    {
        RobustXamlLoader.Load(this);
        IoCManager.InjectDependencies(this);
        _lathe = _ent.System<LatheSystem>();
        Prototype = proto;

        TechnologyNameLabel.Text = Loc.GetString(proto.Name);
        DisciplineTexture.Texture = sprite.Frame0(_proto.Index<TechDisciplinePrototype>(proto.Discipline).Icon);
        TechnologyTexture.Texture = sprite.Frame0(proto.Icon);
        var discipline = _proto.Index<TechDisciplinePrototype>(proto.Discipline);
        var borderStyle = (StyleBoxFlat)TechnologyTextureBorder.PanelOverride!;
        borderStyle.BorderColor = discipline.Color;
        CostValueLabel.Text = proto.Cost.ToString();

        // Обновляем секцию требований
        if (proto.RequiredTech == null || proto.RequiredTech.Count == 0)
        {
            PrereqsContainer.Visible = false;
        }
        else
        {
            PrereqsContainer.Visible = true;
            RequiredTechContainer.DisposeAllChildren();
            foreach (var prereqId in proto.RequiredTech)
            {
                var prereqTech = _proto.Index<TechnologyPrototype>(prereqId);
                var prereqControl = new TechnologyPrereqCardControl(prereqTech, _proto, sprite);
                RequiredTechContainer.AddChild(prereqControl);
            }
        }

        UnlocksContainer.DisposeAllChildren();
        foreach (var item in proto.RecipeUnlocks)
        {
            var recipe = _proto.Index(item);
            var control = new RecipeUnlockCardControl(proto, recipe, _proto, sprite);
            UnlocksContainer.AddChild(control);
        }

        UpdateButtonState(hasAccess, availablity, 0);
        ResearchButton.OnPressed += Bought;
    }

    /// <summary>
    /// Обновляет только состояние кнопки без пересоздания всей панели
    /// </summary>
    public void UpdateButtonState(bool hasAccess, ResearchAvailablity availablity, int availablePoints = 0)
    {
        if (!hasAccess)
            ResearchButton.ToolTip = Loc.GetString("research-console-no-access-popup");
        else
            ResearchButton.ToolTip = null;

        if (availablity == ResearchAvailablity.Researched)
            ResearchButton.Text = Loc.GetString("research-console-menu-server-researched-button");
        else
            ResearchButton.Text = Loc.GetString("research-console-menu-server-research-button");

        bool canAfford = availablePoints >= Prototype.Cost;
        ResearchButton.Disabled = !hasAccess || availablity != ResearchAvailablity.Available || !canAfford;
    }

    protected override void Dispose(bool disposing)
    {
        ResearchButton.OnPressed -= Bought;
        base.Dispose(disposing);
    }

    private void Bought(BaseButton.ButtonEventArgs args)
    {
        BuyAction?.Invoke(Prototype);
    }
}
