using System.Numerics;
using Robust.Client.AutoGenerated;
using Robust.Client.UserInterface.Controls;
using Robust.Client.UserInterface.XAML;
using Robust.Shared.Random;

namespace Content.Client.Paper.UI;

[GenerateTypedNameReferences]
public sealed partial class SignCollection : Container
{
    private List<SignWidget> _signs = new();

    /// Seed for random number generator to place signatures deterministically
    public int PlacementSeed;

    public SignCollection()
    {
        RobustXamlLoader.Load(this);
    }

    /// <summary>
    /// Remove any signatures from the page
    /// </summary>
    public void RemoveSigns()
    {
        _signs.Clear();
        InvalidateArrange();
    }

    /// <summary>
    /// Adds a signature to the display; will perform
    /// automatic layout.
    /// </summary>
    public void AddSign(SignWidget s)
    {
        _signs.Add(s);
        AddChild(s);
    }

    protected override Vector2 ArrangeOverride(Vector2 finalSize)
    {
        // Сдвигаем seed для подписей, чтобы позиции не совпадали с печатями
        var random = new Random(PlacementSeed + 10000);
        var r = (finalSize * 0.5f).Length() * 0.85f; // чуть меньше радиус
        var dtheta = -MathHelper.DegreesToRadians(90);
        var theta0 = random.Next(0, 3) * dtheta + MathHelper.DegreesToRadians(17); // сдвиг фазы
        var thisCenter = PixelSizeBox.TopLeft + finalSize * UIScale * 0.5f;

        // Here's where we lay out the signatures. The first signature goes in the
        // center of this container; subsequent signatures will chose an angle
        // (theta) to place the center of the signature. The signature is moved out
        // as far as it can in that direction, taking the size and
        // orientation of the signature into account.
        for (var i = 0; i < _signs.Count; i++)
        {
            // Больше разброса по углу и радиусу
            var signOrientation = MathHelper.DegreesToRadians((random.NextFloat() - 0.5f) * 15.0f);
            _signs[i].Orientation = signOrientation;

            var theta = theta0 + dtheta * 0.5f + dtheta * i + (i > 4 ? MathF.Log(1 + i / 4) * dtheta : 0) + MathHelper.DegreesToRadians(13);
            var childCenterOnCircle = thisCenter;
            if (i == 0)
            {
                // Первая подпись НЕ в центре, а на случайной позиции по кругу
                var angle = theta0 + MathHelper.DegreesToRadians(random.NextFloat() * 360f);
                childCenterOnCircle += new Vector2(MathF.Cos(angle), MathF.Sin(angle)) * r * UIScale * (0.7f + 0.2f * random.NextFloat());
            }
            else
            {
                // Остальные — как раньше
                childCenterOnCircle += new Vector2(MathF.Cos(theta), MathF.Sin(theta)) * r * UIScale * (0.95f + 0.1f * random.NextFloat());
            }

            var childHeLocal = _signs[i].DesiredPixelSize * 0.5f;
            var c = childHeLocal * MathF.Abs(MathF.Cos(signOrientation));
            var s = childHeLocal * MathF.Abs(MathF.Sin(signOrientation));
            var childHePage = new Vector2(c.X + s.Y, s.X + c.Y);
            var controlBox = new UIBox2(PixelSizeBox.TopLeft, PixelSizeBox.TopLeft + finalSize * UIScale);
            var clampedCenter = Clamp(Shrink(controlBox, childHePage), childCenterOnCircle);
            var finalPosition = clampedCenter - childHePage;
            var finalPositionAsInt = new Vector2i((int)finalPosition.X, (int)finalPosition.Y);
            _signs[i].ArrangePixel(new UIBox2i(finalPositionAsInt, finalPositionAsInt + _signs[i].DesiredPixelSize));
        }

        return finalSize;
    }

    /// <summary>
    /// Shrink a UIBox2 by a half extents, moving both the top-left and
    /// bottom-right closer together.
    /// </summary>
    private UIBox2 Shrink(UIBox2 box, Vector2 shrinkHe)
    {
        return new UIBox2(box.TopLeft + shrinkHe, box.BottomRight - shrinkHe);
    }

    /// <summary>
    /// Returns the input vector clamped to be within the UIBox
    /// </summary>
    private Vector2 Clamp(UIBox2 box, Vector2 point)
    {
        return Vector2.Min(box.BottomRight, Vector2.Max(box.TopLeft, point));
    }
}
