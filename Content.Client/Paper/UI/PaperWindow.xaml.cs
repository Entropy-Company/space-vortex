using System.Numerics;
using Content.Shared.Paper;
using Robust.Client.AutoGenerated;
using Robust.Client.Graphics;
using Robust.Client.Input;
using Robust.Client.ResourceManagement;
using Robust.Client.UserInterface.CustomControls;
using Robust.Client.UserInterface.Controls;
using Robust.Client.UserInterface.XAML;
using Robust.Shared.Utility;
using Robust.Client.UserInterface.RichText;
using Content.Client.UserInterface.RichText;
using Robust.Shared.Input;
using System.Linq;
using System.Collections.Generic;
using System.Text;
using System.Text.RegularExpressions;
using Content.Shared._Eternal.Paper;

namespace Content.Client.Paper.UI
{
    [GenerateTypedNameReferences]
    public sealed partial class PaperWindow : BaseWindow
    {
        [Dependency] private readonly IInputManager _inputManager = default!;
        [Dependency] private readonly IResourceCache _resCache = default!;

        private static Color DefaultTextColor = new(25, 25, 25);

        // <summary>
        // Size of resize handles around the paper
        private const int DRAG_MARGIN_SIZE = 16;

        // We keep a reference to the paper content texture that we create
        // so that we can modify it later.
        private StyleBoxTexture _paperContentTex = new();

        // The number of lines that the content image represents.
        // See PaperVisualsComponent.ContentImageNumLines.
        private float _paperContentLineScale = 1.0f;

        // If paper limits the size in one or both axes, it'll affect whether
        // we're able to resize this UI or not. Default to everything enabled:
        private DragMode _allowedResizeModes = ~DragMode.None;

        private readonly Type[] _allowedTags = new Type[] {
            typeof(BoldItalicTag),
            typeof(BoldTag),
            typeof(BulletTag),
            typeof(ColorTag),
            typeof(FontTag),
            typeof(HeadingTag),
            typeof(ItalicTag),
            typeof(MonoTag)
        };

        public event Action<string>? OnSaved;

        private int _MaxInputLength = -1;
        public int MaxInputLength
        {
            get
            {
                return _MaxInputLength;
            }
            set
            {
                _MaxInputLength = value;
                UpdateFillState();
            }
        }

        // Default signature limit per person (name + color combination)
        private int _signRepeatLimit = 1;
        private int _signLimit = -1; // -1 means no limit

        // Ультрафиолетовое освещение
        private bool _isUltravioletMode = false;

        // Сохраняем оригинальные данные подписей для обновления
        private List<StampDisplayInfo> _originalSignatures = new();

        // Сохраняем оригинальный текст для правильного сохранения скрытых тегов
        private string _originalText = string.Empty;

        private PaperComponent.PaperBoundUserInterfaceState? _lastState;

        public PaperWindow()
        {
            IoCManager.InjectDependencies(this);
            RobustXamlLoader.Load(this);

            // We can't configure the RichTextLabel contents from xaml, so do it here:
            BlankPaperIndicator.SetMessage(Loc.GetString("paper-ui-blank-page-message"), null, DefaultTextColor);

            // Hook up the close button:
            CloseButton.OnPressed += _ => Close();

            Input.OnKeyBindDown += args => // Solution while TextEdit don't have events
            {
                if (args.Function == EngineKeyFunctions.MultilineTextSubmit)
                {
                    // SaveButton is disabled when we hit the max input limit. Just check
                    // that flag instead of trying to calculate the input length again
                    if (!SaveButton.Disabled)
                    {
                        RunOnSaved();
                        args.Handle();
                    }
                }
            };

            Input.OnTextChanged += args =>
            {
                UpdateFillState();
            };

            SaveButton.OnPressed += _ =>
            {
                RunOnSaved();
            };

            SaveButton.Text = Loc.GetString("paper-ui-save-button",
                ("keybind", _inputManager.GetKeyFunctionButtonString(EngineKeyFunctions.MultilineTextSubmit)));
        }

        /// <summary>
        ///     Initialize this UI according to <code>visuals</code> Initializes
        ///     textures, recalculates sizes, and applies some layout rules.
        /// </summary>
        public void InitVisuals(EntityUid entity, PaperVisualsComponent visuals)
        {
            // Randomize the placement of any stamps based on the entity UID
            // so that there's some variety in different papers.
            StampDisplay.PlacementSeed = (int)entity;
            SignDisplay.PlacementSeed = (int)entity;

            // Initialize the background:
            PaperBackground.ModulateSelfOverride = visuals.BackgroundModulate;
            var backgroundImage = visuals.BackgroundImagePath != null? _resCache.GetResource<TextureResource>(visuals.BackgroundImagePath) : null;
            if (backgroundImage != null)
            {
                var backgroundImageMode = visuals.BackgroundImageTile ? StyleBoxTexture.StretchMode.Tile : StyleBoxTexture.StretchMode.Stretch;
                var backgroundPatchMargin = visuals.BackgroundPatchMargin;
                PaperBackground.PanelOverride = new StyleBoxTexture
                {
                    Texture = backgroundImage,
                    TextureScale = visuals.BackgroundScale,
                    Mode = backgroundImageMode,
                    PatchMarginLeft = backgroundPatchMargin.Left,
                    PatchMarginBottom = backgroundPatchMargin.Bottom,
                    PatchMarginRight = backgroundPatchMargin.Right,
                    PatchMarginTop = backgroundPatchMargin.Top
                };

            }
            else
            {
                PaperBackground.PanelOverride = null;
            }


            // Then the header:
            if (visuals.HeaderImagePath != null)
            {
                HeaderImage.TexturePath = visuals.HeaderImagePath;
                HeaderImage.MinSize = HeaderImage.TextureNormal?.Size ?? Vector2.Zero;
            }

            HeaderImage.ModulateSelfOverride = visuals.HeaderImageModulate;
            HeaderImage.Margin = new Thickness(visuals.HeaderMargin.Left, visuals.HeaderMargin.Top,
                    visuals.HeaderMargin.Right, visuals.HeaderMargin.Bottom);

            // Then the footer
            if (visuals.FooterImagePath is {} path)
            {
                FooterImage.TexturePath = path.ToString();
                FooterImage.MinSize = FooterImage.TextureNormal?.Size ?? Vector2.Zero;
            }

            FooterImage.ModulateSelfOverride = visuals.FooterImageModulate;
            FooterImage.Margin = new Thickness(visuals.FooterMargin.Left, visuals.FooterMargin.Top,
                    visuals.FooterMargin.Right, visuals.FooterMargin.Bottom);

            PaperContent.ModulateSelfOverride = visuals.ContentImageModulate;
            WrittenTextLabel.ModulateSelfOverride = visuals.FontAccentColor;
            FillStatus.ModulateSelfOverride = visuals.FontAccentColor;

            var contentImage = visuals.ContentImagePath != null ? _resCache.GetResource<TextureResource>(visuals.ContentImagePath) : null;
            if (contentImage != null)
            {
                // Setup the paper content texture, but keep a reference to it, as we can't set
                // some font-related properties here. We'll fix those up later, in Draw()
                _paperContentTex = new StyleBoxTexture
                {
                    Texture = contentImage,
                    Mode = StyleBoxTexture.StretchMode.Tile,
                };
                PaperContent.PanelOverride = _paperContentTex;
                _paperContentLineScale = visuals.ContentImageNumLines;
            }

            PaperContent.Margin = new Thickness(
                    visuals.ContentMargin.Left, visuals.ContentMargin.Top,
                    visuals.ContentMargin.Right, visuals.ContentMargin.Bottom);

            if (visuals.MaxWritableArea != null)
            {
                var a = (Vector2)visuals.MaxWritableArea;
                // Paper has requested that this has a maximum area that you can write on.
                // So, we'll make the window non-resizable and fix the size of the content.
                // Ideally, would like to be able to allow resizing only one direction.
                ScrollingContents.MinSize = Vector2.Zero;
                ScrollingContents.MinSize = a;

                if (a.X > 0.0f)
                {
                    ScrollingContents.MaxWidth = a.X;
                    _allowedResizeModes &= ~(DragMode.Left | DragMode.Right);

                    // Since this dimension has been specified by the user, we
                    // need to undo the SetSize which was configured in the xaml.
                    // Controls use NaNs to indicate unset for this value.
                    // This is leaky - there should be a method for this
                    SetWidth = float.NaN;
                }

                if (a.Y > 0.0f)
                {
                    ScrollingContents.MaxHeight = a.Y;
                    _allowedResizeModes &= ~(DragMode.Top | DragMode.Bottom);
                    SetHeight = float.NaN;
                }
            }
        }

        /// <summary>
        ///     Control interface. We'll mostly rely on the children to do the drawing
        ///     but in order to get lines on paper to match up with the rich text labels,
        ///     we need to do a small calculation to sync them up.
        /// </summary>
        protected override void Draw(DrawingHandleScreen handle)
        {
            // Now do the deferred setup of the written area. At the point
            // that InitVisuals runs, the label hasn't had it's style initialized
            // so we need to get some info out now:
            if (WrittenTextLabel.TryGetStyleProperty<Font>("font", out var font))
            {
                float fontLineHeight = font.GetLineHeight(1.0f);
                // This positions the texture so the font baseline is on the bottom:
                _paperContentTex.ExpandMarginTop = font.GetDescent(UIScale);
                // And this scales the texture so that it's a single text line:
                var scaleY = (_paperContentLineScale * fontLineHeight) / _paperContentTex.Texture?.Height ?? fontLineHeight;
                _paperContentTex.TextureScale = new Vector2(1, scaleY);

                // Now, we might need to add some padding to the text to ensure
                // that, even if a header is specified, the text will line up with
                // where the content image expects the font to be rendered (i.e.,
                // adjusting the height of the header image shouldn't cause the
                // text to be offset from a line)
                {
                    var headerHeight = HeaderImage.Size.Y + HeaderImage.Margin.Top + HeaderImage.Margin.Bottom;
                    var headerInLines = headerHeight / (fontLineHeight * _paperContentLineScale);
                    var paddingRequiredInLines = (float)Math.Ceiling(headerInLines) - headerInLines;
                    var verticalMargin = fontLineHeight * paddingRequiredInLines * _paperContentLineScale;
                    TextAlignmentPadding.Margin = new Thickness(0.0f, verticalMargin, 0.0f, 0.0f);
                }
            }

            base.Draw(handle);
        }

        /// <summary>
        ///     Initialize the paper contents, i.e. the text typed by the
        ///     user and any stamps that have peen put on the page.
        /// </summary>
        public void Populate(PaperComponent.PaperBoundUserInterfaceState state)
        {
            bool isEditing = state.Mode == PaperComponent.PaperAction.Write;
            bool wasEditing = InputContainer.Visible;
            InputContainer.Visible = isEditing;
            EditButtons.Visible = isEditing;

            SetUltravioletMode(state.IsUltravioletMode);

            // Process text and signatures
            var processedText = state.Text;

            _originalText = state.Text;

            var signatureStyle = SignatureDisplayStyle.Classic;

            var signStyleMatch = Regex.Match(processedText, @"<sign_style\s*=\s*(classic|list|disable)>", RegexOptions.IgnoreCase);
            if (signStyleMatch.Success)
            {
                var style = signStyleMatch.Groups[1].Value.ToLower();
                processedText = Regex.Replace(processedText, @"<sign_style\s*=\s*(classic|list|disable)>", "", RegexOptions.IgnoreCase);
                signatureStyle = style switch
                {
                    "list" => SignatureDisplayStyle.List,
                    "disable" => SignatureDisplayStyle.Disable,
                    _ => SignatureDisplayStyle.Classic
                };
            }

            var signRepeatLimitMatch = Regex.Match(processedText, @"<sign_repeat_limit\s*=\s*(\d+)>", RegexOptions.IgnoreCase);
            if (signRepeatLimitMatch.Success)
            {
                if (int.TryParse(signRepeatLimitMatch.Groups[1].Value, out int limit) && limit > 0)
                {
                    _signRepeatLimit = limit;
                }
                processedText = Regex.Replace(processedText, @"<sign_repeat_limit\s*=\s*(\d+)>", "", RegexOptions.IgnoreCase);
            }
            else
            {
                _signRepeatLimit = 1;
            }

            var signLimitMatch = Regex.Match(processedText, @"<sign_limit\s*=\s*(\d+)>", RegexOptions.IgnoreCase);
            if (signLimitMatch.Success)
            {
                if (int.TryParse(signLimitMatch.Groups[1].Value, out int limit) && limit > 0)
                {
                    _signLimit = limit;
                }
                processedText = Regex.Replace(processedText, @"<sign_limit\s*=\s*(\d+)>", "", RegexOptions.IgnoreCase);
            }
            else
            {
                _signLimit = -1;
            }

            processedText = Regex.Replace(processedText, @"<sign_visible\s*=\s*(true|false)>", "", RegexOptions.IgnoreCase);

            if (!state.IsUltravioletMode)
            {
                processedText = Regex.Replace(processedText, @"\[hidden\](.*?)\[/hidden\]", "", RegexOptions.Singleline);
            }

            // Парсим индексы только из оригинального текста!
            var usedSignatureIndices = new HashSet<int>();
            foreach (Match match in Regex.Matches(state.Text, @"<sign=(\d+)>"))
            {
                if (int.TryParse(match.Groups[1].Value, out int idx))
                    usedSignatureIndices.Add(idx - 1);
            }

            processedText = Regex.Replace(processedText, @"<sign=(\d+)>", match =>
            {
                if (!int.TryParse(match.Groups[1].Value, out int index))
                    return "[color=black][bold]___________[/bold][/color]";
                index--;
                if (index < 0 || index >= state.SingBy.Count)
                    return "[color=black][bold]___________[/bold][/color]";
                var sig = state.SingBy[index];

                var show = true;
                var color = sig.StampedColor;
                if (sig.SignatureType == SignatureType.Invisible)
                {
                    show = _isUltravioletMode;
                }
                else if (sig.SignatureType == SignatureType.Glowing)
                {
                    color = _isUltravioletMode ? Color.White : sig.StampedColor;
                }

                if (!show)
                    return "[color=black][bold]___________[/bold][/color]";

                var colorHex = color.ToHexNoAlpha();
                return $"[font=\"Sign\" size=15][color={colorHex}]{sig.StampedName}[/color][/font]";
            });

            var msg = new FormattedMessage();
            msg.AddMarkupPermissive(processedText);
            msg.AddMarkupPermissive("\r\n");

            WrittenTextLabel.SetMessage(msg, _allowedTags, DefaultTextColor);

            var shouldCopyText = 0 == Input.TextLength && 0 != state.Text.Length;
            if (!wasEditing || shouldCopyText)
            {
                Input.TextRope = Rope.Leaf.Empty;
                Input.CursorPosition = new TextEdit.CursorPos();

                var inputText = state.Text;

                if (isEditing)
                {
                    if (!_isUltravioletMode)
                    {
                        inputText = Regex.Replace(inputText, @"\[hidden\](.*?)\[/hidden\]", "", RegexOptions.Singleline);
                    }
                }
                else
                {
                    if (!_isUltravioletMode)
                    {
                        inputText = Regex.Replace(inputText, @"\[hidden\](.*?)\[/hidden\]", "", RegexOptions.Singleline);
                    }
                }

                Input.InsertAtCursor(inputText);
            }

            WrittenTextLabel.Visible = !isEditing && state.Text.Length > 0;
            BlankPaperIndicator.Visible = !isEditing && state.Text.Length == 0;

            StampDisplay.RemoveAllChildren();
            StampDisplay.RemoveStamps();
            foreach (var stamper in state.StampedBy)
            {
                StampDisplay.AddStamp(new StampWidget { StampInfo = stamper });
            }

            SignDisplay.RemoveAllChildren();
            SignDisplay.RemoveSigns();
            SignatureContainer.RemoveAllChildren();

            _originalSignatures = new List<StampDisplayInfo>(state.SingBy);

            // Собираем лимиты повторов
            var signatureCounts = new Dictionary<string, int>();
            for (int s = 0; s < state.SingBy.Count; s++)
            {
                var signature = state.SingBy[s];
                var key = $"{signature.StampedName}|{signature.StampedColor.ToHexNoAlpha()}";
                var currentCount = signatureCounts.GetValueOrDefault(key, 0);
                if (currentCount < _signRepeatLimit)
                    signatureCounts[key] = currentCount + 1;
            }

            switch (signatureStyle)
            {
                case SignatureDisplayStyle.Classic:
                    for (int s = 0; s < state.SingBy.Count; s++)
                    {
                        // Пропускаем подписи, которые используются в тегах <sign=index>
                        if (usedSignatureIndices.Contains(s))
                            continue;
                        var signature = state.SingBy[s];
                        var key = $"{signature.StampedName}|{signature.StampedColor.ToHexNoAlpha()}";
                        var currentCount = signatureCounts.GetValueOrDefault(key, 0);
                        if (currentCount > 0)
                        {
                            // --- ЭФФЕКТЫ ---
                            var displayColor = signature.StampedColor;
                            bool skip = false;
                            if (signature.SignatureType == SignatureType.Invisible)
                            {
                                if (!_isUltravioletMode)
                                {
                                    skip = true; // не показываем вне УФ
                                }
                            }
                            else if (signature.SignatureType == SignatureType.Glowing)
                            {
                                if (_isUltravioletMode)
                                {
                                    // В УФ — ярко-белый
                                    displayColor = Color.White;
                                }
                                // иначе обычный цвет
                            }
                            if (skip)
                                continue;
                            // --- КОНЕЦ ЭФФЕКТОВ ---
                            SignDisplay.AddSign(new SignWidget
                            {
                                SignInfo = new SignDisplayInfo
                                {
                                    StampedName = signature.StampedName,
                                    StampedColor = displayColor
                                }
                            });
                            signatureCounts[key] = currentCount - 1;
                        }
                    }
                    SignDisplay.Visible = SignDisplay.ChildCount > 0;
                    SignatureContainer.Visible = false;
                    break;
                case SignatureDisplayStyle.List:
                    for (int s = 0; s < state.SingBy.Count; s++)
                    {
                        if (usedSignatureIndices.Contains(s))
                            continue;
                        var signature = state.SingBy[s];
                        var key = $"{signature.StampedName}|{signature.StampedColor.ToHexNoAlpha()}";
                        var currentCount = signatureCounts.GetValueOrDefault(key, 0);
                        if (currentCount > 0)
                        {
                            // --- ЭФФЕКТЫ ---
                            var displayColor = signature.StampedColor;
                            bool skip = false;
                            if (signature.SignatureType == SignatureType.Invisible)
                            {
                                if (!_isUltravioletMode)
                                {
                                    skip = true;
                                }
                            }
                            else if (signature.SignatureType == SignatureType.Glowing)
                            {
                                if (_isUltravioletMode)
                                {
                                    displayColor = Color.White;
                                }
                            }
                            if (skip)
                                continue;
                            // --- КОНЕЦ ЭФФЕКТОВ ---
                            var signWidget = new SignWidget
                            {
                                SignInfo = new SignDisplayInfo
                                {
                                    StampedName = signature.StampedName,
                                    StampedColor = displayColor
                                }
                            };
                            SignatureContainer.AddChild(signWidget);
                            signatureCounts[key] = currentCount - 1;
                        }
                    }
                    SignatureContainer.Visible = SignatureContainer.ChildCount > 0;
                    SignDisplay.Visible = false;
                    break;
                case SignatureDisplayStyle.Disable:
                    SignatureContainer.Visible = false;
                    SignDisplay.Visible = false;
                    break;
            }
        }

        /// <summary>
        /// Определяет, должна ли подпись быть видна в текущем режиме
        /// </summary>
        private bool ShouldShowSignature(StampDisplayInfo signature)
        {
            return signature.SignatureType switch
            {
                SignatureType.Normal => true, // Обычные подписи всегда видны
                SignatureType.Glowing => true, // Светящиеся подписи видны всегда
                SignatureType.Invisible => _isUltravioletMode, // Невидимые видны только под УФ
                _ => true
            };
        }

        /// <summary>
        /// Получает цвет подписи в зависимости от типа и режима освещения
        /// </summary>
        private Color GetSignatureColor(StampDisplayInfo signature)
        {
            return signature.SignatureType switch
            {
                SignatureType.Normal => signature.StampedColor,
                SignatureType.Glowing => _isUltravioletMode ? InvertColor(signature.StampedColor) : signature.StampedColor,
                SignatureType.Invisible => _isUltravioletMode ? signature.StampedColor : Color.Transparent,
                _ => signature.StampedColor
            };
        }

        /// <summary>
        /// Инвертирует цвет для светящихся подписей под УФ
        /// </summary>
        private Color InvertColor(Color color)
        {
            return new Color(255 - color.R, 255 - color.G, 255 - color.B, color.A);
        }

        /// <summary>
        /// Устанавливает режим ультрафиолетового освещения
        /// </summary>
        public void SetUltravioletMode(bool isUltraviolet)
        {
            _isUltravioletMode = isUltraviolet;

            // Применяем фиолетовый оттенок к фону в УФ режиме
            if (_isUltravioletMode)
            {
                // Фиолетовое наложение без прозрачности
                var overlayColor = new Color(0.8f, 0.7f, 1.0f, 1.0f);
                PaperBackground.ModulateSelfOverride = overlayColor;
            }
            else
            {
                PaperBackground.ModulateSelfOverride = Color.White;
            }
        }

        /// <summary>
        ///     BaseWindow interface. Allow users to drag UI around by grabbing
        ///     anywhere on the page (like FancyWindow) but try to calculate
        ///     reasonable dragging bounds because this UI can have round corners,
        ///     and it can be hard to judge where to click to resize.
        /// </summary>
        protected override DragMode GetDragModeFor(Vector2 relativeMousePos)
        {
            var mode = DragMode.None;

            // Be quite generous with resize margins:
            if (relativeMousePos.Y < DRAG_MARGIN_SIZE)
            {
                mode |= DragMode.Top;
            }
            else if (relativeMousePos.Y > Size.Y - DRAG_MARGIN_SIZE)
            {
                mode |= DragMode.Bottom;
            }

            if (relativeMousePos.X < DRAG_MARGIN_SIZE)
            {
                mode |= DragMode.Left;
            }
            else if (relativeMousePos.X > Size.X - DRAG_MARGIN_SIZE)
            {
                mode |= DragMode.Right;
            }

            if((mode & _allowedResizeModes) == DragMode.None)
            {
                return DragMode.Move;
            }
            return mode & _allowedResizeModes;
        }

        private void RunOnSaved()
        {
            // Prevent further saving while text processing still in
            SaveButton.Disabled = true;

            var currentInputText = Rope.Collapse(Input.TextRope);

            if (_isUltravioletMode)
            {
                // Если УФ режим активен, отправляем текущий текст из поля ввода
                OnSaved?.Invoke(currentInputText);
            }
            else
            {
                // Если УФ режим не активен, применяем изменения к оригинальному тексту
                // сохраняя скрытые теги нетронутыми
                var mergedText = MergeChangesWithHiddenTags(_originalText, currentInputText);
                OnSaved?.Invoke(mergedText);
            }
        }

        /// <summary>
        /// Умно объединяет изменения игрока с оригинальным текстом, сохраняя скрытые теги
        /// </summary>
        private string MergeChangesWithHiddenTags(string originalText, string currentText)
        {
            // Находим все скрытые теги в оригинальном тексте
            var hiddenMatches = Regex.Matches(originalText, @"\[hidden\](.*?)\[/hidden\]", RegexOptions.Singleline);

            if (hiddenMatches.Count == 0)
            {
                // Если нет скрытых тегов, просто возвращаем текущий текст
                return currentText;
            }

            // Создаем "видимую" версию оригинального текста (скрытые теги заменены на пробелы)
            var visibleOriginalText = originalText;
            var hiddenTagInfos = new List<(string tag, string spaces, int originalIndex)>();

            foreach (Match match in hiddenMatches)
            {
                var tag = match.Value;
                var content = match.Groups[1].Value;
                var spaces = new string(' ', content.Length);
                var originalIndex = match.Index;
                hiddenTagInfos.Add((tag, spaces, originalIndex));
                visibleOriginalText = visibleOriginalText.Replace(tag, spaces);
            }

            // Если видимый текст не изменился, возвращаем оригинал
            if (visibleOriginalText == currentText)
            {
                return originalText;
            }

            // Применяем изменения, сохраняя позиции скрытых тегов
            var result = currentText;
            var offset = 0;

            // Сортируем теги по позиции в оригинальном тексте
            var sortedTags = hiddenTagInfos.OrderBy(x => x.originalIndex).ToList();

            foreach (var (tag, spaces, originalIndex) in sortedTags)
            {
                // Находим позицию пробелов в текущем тексте
                var adjustedIndex = originalIndex + offset;
                if (adjustedIndex < result.Length)
                {
                    // Проверяем, есть ли пробелы на этой позиции
                    var substring = result.Substring(adjustedIndex, Math.Min(spaces.Length, result.Length - adjustedIndex));
                    if (substring.All(c => c == ' '))
                    {
                        // Заменяем пробелы на оригинальный тег
                        result = result.Substring(0, adjustedIndex) + tag + result.Substring(adjustedIndex + spaces.Length);
                        offset += tag.Length - spaces.Length;
                    }
                }
            }

            return result;
        }

        private void UpdateFillState()
        {
            if (MaxInputLength != -1)
            {
                var inputLength = Input.TextLength;

                FillStatus.Text = Loc.GetString("paper-ui-fill-level",
                    ("currentLength", inputLength),
                    ("maxLength", MaxInputLength));

                // Disable the save button if we've gone over the limit
                SaveButton.Disabled = inputLength > MaxInputLength;
            }
            else
            {
                FillStatus.Text = "";
                SaveButton.Disabled = false;
            }
        }

        public enum SignatureDisplayStyle
        {
            Classic,
            List,
            Disable
        }

        public void UpdateState(PaperComponent.PaperBoundUserInterfaceState state)
        {
            _lastState = state;
            Populate(state);
        }

        // Гарантируем обновление UI при каждом открытии и смене режима
        public new void Open()
        {
            base.Open();
            if (_lastState != null)
                Populate(_lastState);
        }

        public void OnUltravioletModeChanged(bool isUltraviolet)
        {
            SetUltravioletMode(isUltraviolet);
            if (_lastState != null)
                Populate(_lastState);
        }
    }
}
